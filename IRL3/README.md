# IRL3 Data-level-parallelism (SIMD) In-class codes

## Preparation at home
Couple of things to prepare for the IRL session.

### 1. Prepare your machine to be ready to run SIMD instructions.
I have prepared a `hello\_world.c` that works on both Arm Macs and x86
machines.
Please run the following command to ensure everything builds correctly and
that you can use SIMD instructions.

```
make hello_world
./hello_world
```

The `make` command should complete successfully and generate a `hello_world`
binary. If not, follow the error codes and try to figure out what is wrong.
(Copilot, ChatGPT and Claude should be able to help you out here).

If you get a correct output: print out of an array of 64 floating point values
(from 0 to 63) and another print out with 1 to 64, then you should be set to
use SIMD instructions on your machine.

### 2. Prepare the image files that we will use in IRL3
We will be playing around a bit with image files in IRL3. 
If you are using your own machine, download the `images.tar.bz2` from
Studium and decompress the files into the `IRL3` directory.

If you work on Crocodile, use the `setup_img_links.sh` command and it should
create soft links (shortcuts) to the files.

You may also want to look for viewers that can open ppm and pgm files.

Finally, if you want to work with your own images, take a look at the next
section to generate PPM format images :)

### 3. Watch the recorded lectures!
Reminder, watch the recorded lectures so you have an understanding of how SIMD
works.

## References to intrinsics
* [Arm intrinsics](https://developer.arm.com/architectures/instruction-sets/intrinsics/) - filter for NEON instructions. [Arm manual](https://developer.arm.com/documentation/den0018/a/NEON-Intrinsics) has some examples too.
* [x86 intrinsics](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html) - filter for all of the `SSE family` and just the `AVX` within the `AVX family`. (Intel and AMD machines!)

In this module we will look at two tasks.

## 1. Converting a color image into a grayscale image.
To do this, you will be working with a PPM image...

### Information about the PPM format and generating your own PPM images.

**This is interesting information, but not mandatory to read through, if you
want to get started. I have implemented most of the reading from PPM and
writing to PGM in the provided code. Skip this subsection if you want to get
started**

We will use the [PPM format](https://netpbm.sourceforge.net/doc/ppm.html) which is a part of the [Netpbm package](https://netpbm.sourceforge.net).
This is a raster graphics format where each pixel is represented by Red,
Green, and Blue values. The image file dictates how many bits are used to
represent each RGB value in a pixel, but 255 (0-255 meaning a total of 1B)
seems to be the default value for the images generated by tools of the Netpbm
package. 

To install the Netpbm package and some of the conversion tools it provides,
one can use the following functions on Ubuntu or Mac.

``` 
# on a Mac
$ brew install netpbm

#Or on Ubuntu (or Debian based systems)
$ sudo apt install netpbm
```

Then you can use the `jpegtopnm` command to convert a jpeg image of your choosing to ppm.

```
$ jpegtopnm image.jpg > image.ppm
```

You can also use the Mac Preview app or `eog` app on GNOME (works on UPPMAX,
but remember to forward X) to view the image that you are working on.

Furthermore, you can use the [PGM format](https://netpbm.sourceforge.net/doc/pgm.html) when you save the grayscale image.
This format provides one byte per pixel and holds the intensity of the
grayscale image.

### Getting started
Run the `setup_img_links.sh` to setup symbolic links to the images that
I have uploaded into our project shared directory.

```
./setup_img_links.sh
```

If you are working on your own computers, you can download the images
from Studium. Look for `images.tar.bz2` in the modules page under IRL3.

Now, you are ready to start coding.
There are three parts of this program:

1. `grayscale_image.c`: This is the main file you will be working on.
Fill in the `grayscale_image_simd_{sse|avx|neon|neon_fp16}` functions.
2. `ppm.c` and `ppm.h`: This function holds everything to do with the PPM format.
Any reading of actual ppm files, any writing back into pgm files are done here.
We also cheat here. Usually PPM files have R, G, and B value for each pixel interleaved.
This is challenging to work with SIMD as we then need to work with swizzling
data in different parts of the vector register lane, etc.
Therefore, to make this simpler, I have organized the on-memory representation as
an array of Red pixels, another array of Green pixels and finally an array of blue pixels.
This will make SIMD processing much easier!
3. `common.c` and `common.h` At this point, it only holds timer related functions.

Now your implementatin of `grayscale_image_simd_{sse|avx|neon|neon_fp16}` merely
needs to read in each pixel and its three colors (R,G,B) values and calculate the
grayscale value. Use the following formula.
One can use the [ITU-R BT.709](https://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems) standard to convert RGB to grayscale.

```
grayscale = R*0.21 + G*0.72 + B*0.07
```

Once you have implemented your version, say `avx`. You can run your program using the following method:

```
./grayscale_image avx IMG_5440.ppm
```

Then check the generated grayscale image that is in the PGM format. You can use `eog` that is installed on rackham.
You need to have x-forwarding set up to use this.

```
eog IMG_5440.pgm
```

Compare with the IMG\_5440.ppm (again using eog) and you should find that they are similar and PGM file is the gray-scale version of the PPM image.

If you are working from a Mac, instead of eog, you can use the Preview app to view it. From the terminal you can invoke the Preview app by running the following command:

```
open IMG_5440.pgm
```

Once you are ready and fairly convinced that your code is working well, you can run timing experiments by using the following command

```
make run_grayscale_x86 # if you are on an x86 machine, or crocodile
make run_grayscale_arm # if you are working on your Mac with an Apple silicon
```

### Side note for Arm people
Arm CPUs (at least the M1 and later Macs) support fp16. For the purpose of
this lab, we don't need FP32 precision (you can confirm this later on).

And so, there is another version of the neon code you can implement using the
`float16_t`. The PPMImage struct also holds `data_fp16` and
`grayscale_data_fp16` arrays that hold the `float16_t` elements. You can use
these to implement your `neon_fp16` implementation.

Finally, for the `float16_t` results, the provided code will in addition to
the normal `IMG_XXX.pgm` files, also create a `IMG_XXXX_fp16.pgm` so that you
can compare your FP16 and FP32 results. (I could not discern a difference
between the two, but you may have better vision sensitivity than I do ;)

### Hint for everyone
Think about what type of operations you need to do for this task.
All you need to do is set SIMD registers with a certain value, load, multiply, add, and store. 
E.g. `_mm512_load_ps()` or `vld1q_f32()` to get you started!  
Setting all values of the elements in the vector can be done using the `_mm512_set1_ps()` or `vdupq_n_f32()`.

### If you want an extra challenge
You can also try applying a convolution on the image. [Gaussian blur (3x3)](https://en.wikipedia.org/wiki/Kernel_(image_processing)#Details) would be the most simplest. 
Also note that Gaussian blur is seperable and thus you can independantly do two 1D convolutions per pixel, one on the horizontal and the other on the vertical axis.
I have not tried this out myself, but if you like the challenge, please give it a try and let me know how it goes!
If you wish, you could choose to do your group presentation by presenting how you applied the Gaussian blur, how it compares in performance to a scalar implementation (non SIMD), and how the two points (scalar and vector version) are placed on the roofline model. 


## 2. Monte-carlo Pi simulation
Generate many 100s of millions of random points with ranges [0,1] for both the x and y value.
Then go through each of the random point and measure the euclidean distance between the point and the origin.
If the distance is less-than or equal to 1, then you can say that this point lies within the radius of the circle.
(Assume that we have a circle `x^2 + y^2 = 1` and we are only looking at the first quadrant)
Now, you can get a portion out of the total points, how many lie within the distance of 1 and multiply by 4 and you get pi.
(Because the area of a circle of radius of 1 is pi).

Implement this in SIMD! I have implemented the non-vectorized version for you.

Oh and the file you will work on is `pi.c`.

Once you `make pi` you can run say your `neon` version using the following instruction.

```
./pi neon
```

If you have implemented both sse and avx, or just neon; you can compare non-vectorized (serial) and your vectorized version using the following command:

```
make run_pi_x86 # if you are on an x86 machine, or rackham/snowy
make run_pi_arm # if you are working on your Mac with an Apple silicon
```

Make sure to check that the Pi value printed for your SIMD version is relatively close to the Pi value from the serial version!

### Hint
When comparing whether the distance of the point from the origin is less than or equal to 1.0, you will be using compare operators (`_mm_cmp_ps()`, `vcleq_f32()`).
Be wary that these operators will return values where all the corresponding bits of that lane will be set to 1. 
E.g. if you have a 128-bit vector with 4x32-bit floats and the first element is within the 1.0 distance. The 32 bits of the first element's lane will all be set to 1s.
You will need to convert this value into a value `1` for each lane, then you can do a cross-lane addition (`vaddvq_u32()`), or if you have AVX512 you can use the `_mm_cmp_ps_mask()` which will provide one bit per lane, then you can use one of the `popcnt` instructions to count all the values.

**If you need more challenge, try to do the pi calculation through integration method using SIMD!**



